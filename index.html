<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GeoJSON Canvas Viewer</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        canvas {
            border: 2px solid #333;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .info {
            margin-top: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            max-width: 600px;
        }
        .info p {
            margin: 5px 0;
            color: #666;
        }
        .controls {
            margin-bottom: 20px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .controls button {
            margin-right: 10px;
        }
        .mode-active {
            background: #1a73e8 !important;
            color: white !important;
        }
        .annotation {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.2);
            pointer-events: none;
            z-index: 50;
            border: 1px solid #ddd;
            font-weight: 500;
            color: #333;
        }
        .drawing-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .drawing-modal.show {
            display: flex;
        }
        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }
        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        #mainCanvas .canvas-wrapper {
            position: relative;
        }
        #drawingCanvasContainer .canvas-wrapper {
            position: relative;
            display: inline-block;
        }
        .drawing-container {
            position: relative;
            background: white;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }
        #mainCanvas {
            display: block;
        }
        #drawingCanvasContainer {
            display: none;
        }
        .view-toggle {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }
        .canvas-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .canvas-tab {
            padding: 8px 16px;
            border: 2px solid #ddd;
            background: #f1f3f4;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #5f6368;
            transition: all 0.2s;
        }
        .canvas-tab:hover {
            background: #e8eaed;
            border-color: #4285f4;
        }
        .canvas-tab.active {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }
        .geo-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .geo-tab {
            padding: 8px 16px;
            border: 2px solid #ddd;
            background: #f1f3f4;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #5f6368;
            transition: all 0.2s;
        }
        .geo-tab:hover {
            background: #e8eaed;
            border-color: #4285f4;
        }
        .geo-tab.active {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }
        .geo-area {
            position: relative;
            display: flex;
        }
        .geo-panels {
            position: relative;
        }
        .geo-panel {
            display: none;
            position: relative;
        }
        .geo-panel.active {
            display: block;
        }
        .canvas-area {
            position: relative;
            display: flex;
        }
        .canvas-panels {
            position: relative;
        }
        .canvas-panel {
            display: none;
            position: relative;
        }
        .canvas-panel.active {
            display: block;
        }
        .drawing-tools {
            position: absolute;
            top: 20px;
            right: -180px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 90%;
            overflow-y: auto;
            width: 160px;
        }
        .tool-btn {
            padding: 8px 12px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            text-align: left;
            transition: all 0.2s;
        }
        .tool-btn:hover {
            background: #f5f5f5;
            border-color: #4285f4;
        }
        .tool-btn.active {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }
        .drawing-canvas {
            border: 2px solid #ddd;
            background: white;
            cursor: crosshair;
            position: relative;
        }
        .preview-layer {
            z-index: 10;
        }
        .eraser-cursor {
            position: absolute;
            border: 2px solid #ea4335;
            pointer-events: none;
            display: none;
            background: rgba(234, 67, 53, 0.1);
        }
        .eraser-cursor.circle {
            border-radius: 50%;
        }
        .eraser-cursor.square {
            border-radius: 0;
        }
        .text-input-box {
            position: absolute;
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
            padding: 5px;
            min-width: 100px;
            min-height: 30px;
            display: none;
        }
        .text-input-box input {
            border: none;
            background: transparent;
            outline: none;
            font-size: 16px;
            width: 100%;
        }
        .close-drawing {
            position: absolute;
            top: 10px;
            left: 10px;
            background: #ea4335;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            z-index: 10;
        }
        .close-drawing:hover {
            background: #c5221f;
        }
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #f5f5f5;
            border-radius: 6px;
        }
        .color-picker-container label {
            font-size: 12px;
            font-weight: 500;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .modal.show {
            display: flex;
        }
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 8px 16px rgba(0,0,0,0.2);
            max-width: 400px;
            width: 90%;
        }
        .modal-content h2 {
            margin-top: 0;
            color: #333;
            font-size: 20px;
        }
        .modal-content textarea {
            width: 100%;
            height: 100px;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            resize: vertical;
            box-sizing: border-box;
        }
        .modal-content textarea:focus {
            outline: none;
            border-color: #4285f4;
        }
        .modal-content select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            box-sizing: border-box;
            background: white;
        }
        .modal-content select:focus {
            outline: none;
            border-color: #4285f4;
        }
        .modal-buttons {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: flex-end;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }
        .btn-primary {
            background: #4285f4;
            color: white;
        }
        .btn-primary:hover {
            background: #3367d6;
        }
        .btn-secondary {
            background: #f1f3f4;
            color: #5f6368;
        }
        .btn-secondary:hover {
            background: #e8eaed;
        }
        .point-label {
            position: absolute;
            background: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            pointer-events: none;
            z-index: 100;
            transform: translate(0, 0);
        }
        #labels {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .polygon-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(66, 133, 244, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 1000;
            display: none;
        }
        .polygon-hint.show {
            display: block;
        }
        .style-selector-container {
            position: relative;
        }
        .style-selector-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid #ddd;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            margin-top: 5px;
            padding: 8px;
        }
        .style-selector-dropdown.show {
            display: block;
        }
        .style-option-group {
            margin-bottom: 12px;
        }
        .style-option-group:last-child {
            margin-bottom: 0;
        }
        .style-option-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #5f6368;
            margin-bottom: 6px;
        }
        .style-options {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
        }
        .style-option {
            flex: 1;
            min-width: 60px;
            padding: 6px 8px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.2s;
        }
        .style-option:hover {
            background: #f5f5f5;
            border-color: #4285f4;
        }
        .style-option.active {
            background: #4285f4;
            color: white;
            border-color: #4285f4;
        }
    </style>
</head>
<body>
    <h1>GeoJSON Canvas Viewer</h1>
    
    <div class="view-toggle">
        <button id="geoViewBtn" class="btn btn-primary mode-active">GeoJSON View</button>
        <button id="drawViewBtn" class="btn btn-secondary">Custom Drawing View</button>
    </div>
    
    <div class="main-container">
        <!-- GeoJSON View -->
        <div id="mainCanvas">
            <div class="controls">
                <button id="selectMode" class="btn btn-primary mode-active">Select Mode</button>
                <button id="addMode" class="btn btn-secondary">Add Pin Mode</button>
                <button id="annotateMode" class="btn btn-secondary">Annotate Mode</button>
                <button id="clearPins" class="btn btn-secondary">Clear Custom Pins</button>
                <button id="exportGeoJSON" class="btn btn-primary">Export GeoJSON</button>
                <button id="captureGeoImage" class="btn btn-primary">üì∑ Capture Image</button>
            </div>
            <div class="geo-tabs">
                <button class="geo-tab active" data-geo="1">Polygon Map 1</button>
                <button class="geo-tab" data-geo="2">Polygon Map 2</button>
            </div>
            <div class="geo-area">
                <div class="geo-panels">
                    <div class="geo-panel active" id="geoPanel1">
                        <div class="controls">
                            <label for="rotationSlider1" style="margin-right: 10px; font-weight: 500;">Rotate Polygon:</label>
                            <input type="range" id="rotationSlider1" min="0" max="360" value="0" style="width: 300px; vertical-align: middle;">
                            <span id="rotationValue1" style="margin-left: 10px; font-weight: 500;">0¬∞</span>
                            <button id="resetRotation1" class="btn btn-secondary" style="margin-left: 15px;">Reset Rotation</button>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="mapCanvas1" width="800" height="600"></canvas>
                            <div id="labels1"></div>
                            <div id="annotations1"></div>
                        </div>
                    </div>
                    <div class="geo-panel" id="geoPanel2">
                        <div class="controls">
                            <label for="rotationSlider2" style="margin-right: 10px; font-weight: 500;">Rotate Polygon:</label>
                            <input type="range" id="rotationSlider2" min="0" max="360" value="0" style="width: 300px; vertical-align: middle;">
                            <span id="rotationValue2" style="margin-left: 10px; font-weight: 500;">0¬∞</span>
                            <button id="resetRotation2" class="btn btn-secondary" style="margin-left: 15px;">Reset Rotation</button>
                        </div>
                        <div class="canvas-wrapper">
                            <canvas id="mapCanvas2" width="800" height="600"></canvas>
                            <div id="labels2"></div>
                            <div id="annotations2"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="info">
                <p><strong>Polygon:</strong> <span style="color: #4285f4;">Blue fill</span> with <span style="color: #1a73e8;">dark blue stroke</span></p>
                <p><strong>Original Points:</strong> <span style="color: #ea4335;">Red circles</span></p>
                <p><strong>Custom Pins:</strong> <span style="color: #34a853;">Green circles</span> - Added by you</p>
                <p><strong>Annotations:</strong> <span style="color: #fbbc04;">Yellow labels</span> - Click anywhere to add text annotations</p>
                <p><strong>Tip:</strong> Switch modes to add pins, annotate anywhere, or select points. Click any point to add text.</p>
                <p><strong>Location:</strong> Paris, France (near the Louvre)</p>
            </div>
        </div>
        
        <!-- Custom Drawing View -->
        <div id="drawingCanvasContainer">
            <div class="controls">
                <button id="drawSelectMode" class="btn btn-secondary">Select Mode</button>
                <button id="drawAddPinMode" class="btn btn-secondary">Add Pin Mode</button>
                <button id="drawAnnotateMode" class="btn btn-secondary">Annotate Mode</button>
                <button id="drawClear" class="btn btn-secondary">Clear</button>
                <button id="exportDrawing" class="btn btn-primary">Export Drawing</button>
                <button id="captureDrawingImage" class="btn btn-primary">üì∑ Capture Image</button>
            </div>
            <div class="canvas-tabs">
                <button class="canvas-tab active" data-canvas="1">Structure 1</button>
                <button class="canvas-tab" data-canvas="2">Structure 2</button>
            </div>
            <div class="canvas-area">
                <div class="canvas-panels">
                    <div class="canvas-wrapper canvas-panel active" id="canvasPanel1">
                        <canvas id="drawingCanvas1" class="drawing-canvas" width="1000" height="700"></canvas>
                        <div id="eraserCursor1" class="eraser-cursor"></div>
                        <div id="textInputBox1" class="text-input-box">
                            <input type="text" id="textInput1" placeholder="Type text here...">
                        </div>
                        <div id="drawLabels1"></div>
                        <div id="drawAnnotations1"></div>
                    </div>
                    <div class="canvas-wrapper canvas-panel" id="canvasPanel2">
                        <canvas id="drawingCanvas2" class="drawing-canvas" width="1000" height="700"></canvas>
                        <div id="eraserCursor2" class="eraser-cursor"></div>
                        <div id="textInputBox2" class="text-input-box">
                            <input type="text" id="textInput2" placeholder="Type text here...">
                        </div>
                        <div id="drawLabels2"></div>
                        <div id="drawAnnotations2"></div>
                    </div>
                </div>
                <div class="drawing-tools">
                    <button class="tool-btn active" data-tool="pencil">‚úèÔ∏è Pencil</button>
                    <button class="tool-btn" data-tool="line">üìè Line</button>
                    <button class="tool-btn" data-tool="rectangle">‚ñ≠ Rectangle</button>
                    <button class="tool-btn" data-tool="circle">‚≠ï Circle</button>
                    <button class="tool-btn" data-tool="eraser">üßπ Eraser</button>
                    <button class="tool-btn" data-tool="closedPolygon">‚¨° Closed Polygon</button>
                    <button class="tool-btn" data-tool="openPolygon">‚öä Open Polygon</button>
                    <button class="tool-btn" data-tool="text">üìù Text</button>
                    <button class="tool-btn" data-tool="undo" style="background: #fff3cd; border-color: #ffc107;">‚Ü∂ Undo</button>
                    <button class="tool-btn" data-tool="redo" style="background: #d1ecf1; border-color: #17a2b8;">‚Ü∑ Redo</button>
                    <div class="style-selector-container">
                        <button class="tool-btn" id="styleSelectorBtn">‚öôÔ∏è Line & Rectangle Style</button>
                        <div class="style-selector-dropdown" id="styleSelectorDropdown">
                            <div class="style-option-group">
                                <label>Line Style:</label>
                                <div class="style-options">
                                    <div class="style-option active" data-type="line" data-style="solid">Solid</div>
                                    <div class="style-option" data-type="line" data-style="dashed">Dashed</div>
                                    <div class="style-option" data-type="line" data-style="dotted">Dotted</div>
                                </div>
                            </div>
                            <div class="style-option-group">
                                <label>Rectangle Style:</label>
                                <div class="style-options">
                                    <div class="style-option active" data-type="rectangle" data-style="solid">Solid</div>
                                    <div class="style-option" data-type="rectangle" data-style="dotted">Dotted</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="color-picker-container">
                        <label>Color:</label>
                        <input type="color" id="drawingColor" value="#000000">
                    </div>
                    <div class="color-picker-container">
                        <label>Width:</label>
                        <input type="range" id="lineWidth" min="1" max="20" value="2" style="width: 80px;">
                    </div>
                    <div class="color-picker-container" id="eraserSizeContainer" style="display: none;">
                        <label>Eraser:</label>
                        <input type="range" id="eraserSize" min="5" max="50" value="20" style="width: 80px;">
                    </div>
                    <div class="color-picker-container" id="eraserTypeContainer" style="display: none;">
                        <label>Shape:</label>
                        <select id="eraserType" style="width: 90px; padding: 4px; border: 1px solid #ddd; border-radius: 4px;">
                            <option value="circle">Circle</option>
                            <option value="square">Square</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="polygon-hint" id="polygonHint">
                Click to add points. Press <strong>ESC</strong> to finish or <strong>Double-click</strong> to complete polygon.
            </div>
            <div class="info">
                <p><strong>Custom Pins:</strong> <span style="color: #34a853;">Green circles</span> - Click in Add Pin Mode to add</p>
                <p><strong>Annotations:</strong> <span style="color: #fbbc04;">Yellow labels</span> - Click anywhere to add text</p>
                <p><strong>Tip:</strong> Use drawing tools to create, then switch to Select/Add Pin/Annotate modes for interactive features</p>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div class="modal-content">
            <h2 id="modalTitle">Add Custom Text</h2>
            <textarea id="customText" placeholder="Enter your custom text here..."></textarea>
            <select id="termiteType" style="display: none;">
                <option value="">Select Termite Type</option>
                <option value="Subterranean Termites">Subterranean Termites</option>
                <option value="Drywood Termites">Drywood Termites</option>
                <option value="Dampwood Termites">Dampwood Termites</option>
                <option value="Formosan Termites">Formosan Termites</option>
                <option value="Conehead Termites">Conehead Termites</option>
            </select>
            <div class="modal-buttons">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveText()">Save</button>
            </div>
        </div>
    </div>

    <!-- html2canvas library for capturing canvas-wrapper -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <script>
        const geojson = {
            "type": "FeatureCollection",
            "features": [
                {
                    "id": "94fc1a86-1843-4db8-94bc-5cbac98c4bf9",
                    "type": "Feature",
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [2.306948881, 48.854796034],
                                [2.306978124, 48.854759168],
                                [2.307025219, 48.854728772],
                                [2.307238865, 48.85487281],
                                [2.307318225, 48.854893604],
                                [2.307223739, 48.855001572],
                                [2.307159854, 48.854976422],
                                [2.307193695, 48.854942818],
                                [2.307148268, 48.854934899],
                                [2.306948881, 48.854796034]
                            ]
                        ]
                    },
                    "properties": {"mode": "polygon"}
                },
                {
                    "id": "b63873db-5640-4eec-a6f3-34a2465e3c52",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.306978517, 48.854798228]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "fd6414b6-6c63-4c05-b71f-370a78cd5821",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307034996, 48.854752626]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "4f6222a3-7368-4be5-9f12-d1b30388f8c7",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307160875, 48.854832965]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "d066ee45-f19e-4f65-9046-7b4e62c25928",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307235906, 48.854884407]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "075dcbc5-4f5f-4527-ac33-7e5f2837842a",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.30727572, 48.854902963]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "37541006-23e1-42a4-97e8-ff3125aa8fcf",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307211836, 48.854975653]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "5c64cf67-a71d-4330-80c4-b31d4a50c7e1",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.3070859, 48.854876006]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "443a7dc9-1e22-4be7-b7ed-2381a72bc28c",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307037513, 48.854848535]},
                    "properties": {"mode": "point"}
                },
                {
                    "id": "dcb8d8ae-455d-4e49-a1e0-d44be3ee511f",
                    "type": "Feature",
                    "geometry": {"type": "Point", "coordinates": [2.307166889, 48.854927092]},
                    "properties": {"mode": "point"}
                }
            ]
        };

        const modal = document.getElementById('modal');
        const modalTitle = document.getElementById('modalTitle');
        const textArea = document.getElementById('customText');
        const termiteTypeSelect = document.getElementById('termiteType');
        
        const selectModeBtn = document.getElementById('selectMode');
        const addModeBtn = document.getElementById('addMode');
        const annotateModeBtn = document.getElementById('annotateMode');
        const clearPinsBtn = document.getElementById('clearPins');
        const exportBtn = document.getElementById('exportGeoJSON');
        const geoViewBtn = document.getElementById('geoViewBtn');
        const drawViewBtn = document.getElementById('drawViewBtn');
        const mainCanvas = document.getElementById('mainCanvas');
        const drawingCanvasContainer = document.getElementById('drawingCanvasContainer');
        const geoTabs = document.querySelectorAll('.geo-tab');
        const geoPanels = {
            1: document.getElementById('geoPanel1'),
            2: document.getElementById('geoPanel2')
        };
        
        let mode = 'select'; // 'select' or 'add' or 'annotate'
        let canvasStates = {};
        let activeCanvasId = 1;
        let activeState = null;
        let geoStates = {};
        let activeGeoId = 1;
        let activeGeoState = null;
        
        // Find bounds of all coordinates
        function getBounds(features) {
            let minLon = Infinity, maxLon = -Infinity;
            let minLat = Infinity, maxLat = -Infinity;
            
            features.forEach(feature => {
                if (feature.geometry.type === 'Polygon') {
                    feature.geometry.coordinates[0].forEach(coord => {
                        minLon = Math.min(minLon, coord[0]);
                        maxLon = Math.max(maxLon, coord[0]);
                        minLat = Math.min(minLat, coord[1]);
                        maxLat = Math.max(maxLat, coord[1]);
                    });
                } else if (feature.geometry.type === 'Point') {
                    minLon = Math.min(minLon, feature.geometry.coordinates[0]);
                    maxLon = Math.max(maxLon, feature.geometry.coordinates[0]);
                    minLat = Math.min(minLat, feature.geometry.coordinates[1]);
                    maxLat = Math.max(maxLat, feature.geometry.coordinates[1]);
                }
            });
            
            return { minLon, maxLon, minLat, maxLat };
        }
        
        // Convert lat/lon to canvas x/y
        function projectToCanvas(lon, lat, bounds) {
            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;
            
            let x = padding + ((lon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width;
            // Flip Y because canvas Y increases downward but latitude increases upward
            let y = padding + ((bounds.maxLat - lat) / (bounds.maxLat - bounds.minLat)) * height;
            
            // Apply rotation if needed
            if (rotationAngle !== 0 && centerPoint) {
                const rotated = rotatePoint(x, y, centerPoint.x, centerPoint.y, rotationAngle);
                x = rotated.x;
                y = rotated.y;
            }
            
            return { x, y };
        }
        
        // Rotate a point around a center
        function rotatePoint(x, y, cx, cy, angleDeg) {
            const angleRad = (angleDeg * Math.PI) / 180;
            const cos = Math.cos(angleRad);
            const sin = Math.sin(angleRad);
            
            const dx = x - cx;
            const dy = y - cy;
            
            return {
                x: cos * dx - sin * dy + cx,
                y: sin * dx + cos * dy + cy
            };
        }
        
        // Inverse rotation for click detection
        function inverseRotatePoint(x, y, cx, cy, angleDeg) {
            return rotatePoint(x, y, cx, cy, -angleDeg);
        }
        
        // Calculate center point of the polygon
        function calculateCenter(bounds) {
            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;
            
            const centerLon = (bounds.minLon + bounds.maxLon) / 2;
            const centerLat = (bounds.minLat + bounds.maxLat) / 2;
            
            const x = padding + ((centerLon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width;
            const y = padding + ((bounds.maxLat - centerLat) / (bounds.maxLat - bounds.minLat)) * height;
            
            return { x, y };
        }
        
        // Convert canvas x/y back to lat/lon
        function canvasToLatLon(x, y, bounds) {
            const padding = 50;
            const width = canvas.width - padding * 2;
            const height = canvas.height - padding * 2;
            
            const lon = bounds.minLon + ((x - padding) / width) * (bounds.maxLon - bounds.minLon);
            const lat = bounds.maxLat - ((y - padding) / height) * (bounds.maxLat - bounds.minLat);
            
            return { lon, lat };
        }
        
        // Check if a point is inside the polygon
        function isPointInPolygon(x, y, polygon) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x, yi = polygon[i].y;
                const xj = polygon[j].x, yj = polygon[j].y;
                
                const intersect = ((yi > y) !== (yj > y))
                    && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }
        
        // Create GeoJSON state for each view
        function createGeoState(id) {
            const canvas = document.getElementById(`mapCanvas${id}`);
            const ctx = canvas.getContext('2d');
            const state = {
                id,
                canvas,
                ctx,
                labelsContainer: document.getElementById(`labels${id}`),
                annotationsContainer: document.getElementById(`annotations${id}`),
                rotationSlider: document.getElementById(`rotationSlider${id}`),
                rotationValue: document.getElementById(`rotationValue${id}`),
                resetRotationBtn: document.getElementById(`resetRotation${id}`),
                geojson: JSON.parse(JSON.stringify(geojson)), // Deep copy
                pointsData: [],
                selectedPointIndex: null,
                bounds: null,
                customPins: [],
                annotations: [],
                selectedAnnotationIndex: null,
                rotationAngle: 0,
                centerPoint: null
            };
            
            // Attach canvas click event
            canvas.addEventListener('click', (e) => handleGeoCanvasClick(e, state));
            
            // Attach rotation controls
            state.rotationSlider.addEventListener('input', (e) => {
                state.rotationAngle = parseInt(e.target.value, 10);
                state.rotationValue.textContent = state.rotationAngle + '¬∞';
                drawGeoJSON(state);
            });
            
            state.resetRotationBtn.addEventListener('click', () => {
                state.rotationAngle = 0;
                state.rotationSlider.value = 0;
                state.rotationValue.textContent = '0¬∞';
                drawGeoJSON(state);
            });
            
            return state;
        }
        
        // Convert lat/lon to canvas x/y (with state)
        function projectToCanvasState(lon, lat, bounds, state) {
            const padding = 50;
            const width = state.canvas.width - padding * 2;
            const height = state.canvas.height - padding * 2;
            
            let x = padding + ((lon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width;
            let y = padding + ((bounds.maxLat - lat) / (bounds.maxLat - bounds.minLat)) * height;
            
            if (state.rotationAngle !== 0 && state.centerPoint) {
                const rotated = rotatePoint(x, y, state.centerPoint.x, state.centerPoint.y, state.rotationAngle);
                x = rotated.x;
                y = rotated.y;
            }
            
            return { x, y };
        }
        
        // Calculate center point (with state)
        function calculateCenterState(bounds, state) {
            const padding = 50;
            const width = state.canvas.width - padding * 2;
            const height = state.canvas.height - padding * 2;
            
            const centerLon = (bounds.minLon + bounds.maxLon) / 2;
            const centerLat = (bounds.minLat + bounds.maxLat) / 2;
            
            const x = padding + ((centerLon - bounds.minLon) / (bounds.maxLon - bounds.minLon)) * width;
            const y = padding + ((bounds.maxLat - centerLat) / (bounds.maxLat - bounds.minLat)) * height;
            
            return { x, y };
        }
        
        // Convert canvas x/y back to lat/lon (with state)
        function canvasToLatLonState(x, y, bounds, state) {
            const padding = 50;
            const width = state.canvas.width - padding * 2;
            const height = state.canvas.height - padding * 2;
            
            const lon = bounds.minLon + ((x - padding) / width) * (bounds.maxLon - bounds.minLon);
            const lat = bounds.maxLat - ((y - padding) / height) * (bounds.maxLat - bounds.minLat);
            
            return { lon, lat };
        }
        
        // Draw the GeoJSON (with state)
        function drawGeoJSON(state = activeGeoState) {
            if (!state) return;
            
            state.bounds = getBounds(state.geojson.features);
            state.centerPoint = calculateCenterState(state.bounds, state);
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.pointsData = [];
            let polygonPoints = [];
            
            state.geojson.features.forEach((feature, index) => {
                if (feature.geometry.type === 'Polygon') {
                    state.ctx.beginPath();
                    const coords = feature.geometry.coordinates[0];
                    coords.forEach((coord, i) => {
                        const { x, y } = projectToCanvasState(coord[0], coord[1], state.bounds, state);
                        polygonPoints.push({ x, y });
                        
                        if (i === 0) {
                            state.ctx.moveTo(x, y);
                        } else {
                            state.ctx.lineTo(x, y);
                        }
                    });
                    state.ctx.closePath();
                    
                    state.ctx.fillStyle = 'rgba(66, 133, 244, 0.3)';
                    state.ctx.fill();
                    state.ctx.strokeStyle = '#1a73e8';
                    state.ctx.lineWidth = 2;
                    state.ctx.stroke();
                    
                } else if (feature.geometry.type === 'Point') {
                    const { x, y } = projectToCanvasState(
                        feature.geometry.coordinates[0],
                        feature.geometry.coordinates[1],
                        state.bounds,
                        state
                    );
                    
                    state.pointsData.push({
                        x, y,
                        featureId: feature.id,
                        text: feature.properties.customText || '',
                        isCustom: false
                    });
                    
                    state.ctx.beginPath();
                    state.ctx.arc(x, y, 5, 0, Math.PI * 2);
                    state.ctx.fillStyle = '#ea4335';
                    state.ctx.fill();
                    state.ctx.strokeStyle = '#c5221f';
                    state.ctx.lineWidth = 1;
                    state.ctx.stroke();
                }
            });
            
            state.customPins.forEach(pin => {
                const { x, y } = projectToCanvasState(pin.lon, pin.lat, state.bounds, state);
                
                state.pointsData.push({
                    x, y,
                    featureId: pin.id,
                    text: pin.text || '',
                    isCustom: true
                });
                
                state.ctx.beginPath();
                state.ctx.arc(x, y, 5, 0, Math.PI * 2);
                state.ctx.fillStyle = '#34a853';
                state.ctx.fill();
                state.ctx.strokeStyle = '#1e8e3e';
                state.ctx.lineWidth = 1;
                state.ctx.stroke();
            });
            
            renderLabels(state);
            renderAnnotations(state);
            return polygonPoints;
        }
        
        // Render labels for points with custom text (with state)
        function renderLabels(state = activeGeoState) {
            if (!state) return;
            state.labelsContainer.innerHTML = '';
            
            state.pointsData.forEach(point => {
                if (point.text) {
                    const label = document.createElement('div');
                    label.className = 'point-label';
                    label.textContent = point.text;
                    label.style.left = (point.x + 10) + 'px';
                    label.style.top = (point.y - 10) + 'px';
                    state.labelsContainer.appendChild(label);
                }
            });
        }
        
        // Render annotations for polygon edges (with state)
        function renderAnnotations(state = activeGeoState) {
            if (!state) return;
            state.annotationsContainer.innerHTML = '';
            
            state.annotations.forEach((annotation, idx) => {
                const { x, y } = projectToCanvasState(annotation.lon, annotation.lat, state.bounds, state);
                
                const label = document.createElement('div');
                label.className = 'annotation';
                label.textContent = annotation.text;
                label.style.left = x + 'px';
                label.style.top = y + 'px';
                label.style.transform = 'translate(-50%, -50%)';
                label.style.background = 'rgba(251, 188, 4, 0.95)';
                label.style.cursor = mode === 'select' ? 'pointer' : 'default';
                label.style.pointerEvents = mode === 'select' ? 'auto' : 'none';
                
                if (mode === 'select') {
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        state.selectedAnnotationIndex = idx;
                        textArea.value = annotation.text;
                        textArea.dataset.annotationEdit = 'true';
                        textArea.dataset.activeGeoId = state.id;
                        modalTitle.textContent = 'Edit Annotation';
                        textArea.style.display = 'block';
                        termiteTypeSelect.style.display = 'none';
                        modal.classList.add('show');
                    });
                }
                
                state.annotationsContainer.appendChild(label);
            });
        }
        
        // Handle canvas clicks (with state)
        function handleGeoCanvasClick(e, state) {
            if (state.id !== activeGeoId) return;
            
            const rect = state.canvas.getBoundingClientRect();
            let clickX = e.clientX - rect.left;
            let clickY = e.clientY - rect.top;
            
            if (mode === 'select') {
                let foundPoint = false;
                state.pointsData.forEach((point, idx) => {
                    const distance = Math.sqrt(
                        Math.pow(clickX - point.x, 2) + 
                        Math.pow(clickY - point.y, 2)
                    );
                    
                    if (distance <= 8) {
                        state.selectedPointIndex = idx;
                        textArea.dataset.activeGeoId = state.id;
                        termiteTypeSelect.value = point.text || '';
                        modalTitle.textContent = 'Select Termite Type';
                        textArea.style.display = 'none';
                        termiteTypeSelect.style.display = 'block';
                        modal.classList.add('show');
                        foundPoint = true;
                    }
                });
            } else if (mode === 'add') {
                let checkX = clickX;
                let checkY = clickY;
                if (state.rotationAngle !== 0 && state.centerPoint) {
                    const inverted = inverseRotatePoint(clickX, clickY, state.centerPoint.x, state.centerPoint.y, state.rotationAngle);
                    checkX = inverted.x;
                    checkY = inverted.y;
                }
                
                const polygonPoints = [];
                state.geojson.features.forEach(feature => {
                    if (feature.geometry.type === 'Polygon') {
                        feature.geometry.coordinates[0].forEach(coord => {
                            const padding = 50;
                            const width = state.canvas.width - padding * 2;
                            const height = state.canvas.height - padding * 2;
                            
                            const x = padding + ((coord[0] - state.bounds.minLon) / (state.bounds.maxLon - state.bounds.minLon)) * width;
                            const y = padding + ((state.bounds.maxLat - coord[1]) / (state.bounds.maxLat - state.bounds.minLat)) * height;
                            polygonPoints.push({ x, y });
                        });
                    }
                });
                
                if (isPointInPolygon(checkX, checkY, polygonPoints)) {
                    const { lon, lat } = canvasToLatLonState(checkX, checkY, state.bounds, state);
                    
                    const newPin = {
                        id: 'custom-' + Date.now(),
                        lon,
                        lat,
                        text: ''
                    };
                    state.customPins.push(newPin);
                    drawGeoJSON(state);
                } else {
                    alert('Please click inside the blue polygon area to add a pin');
                }
            } else if (mode === 'annotate') {
                let annotateX = clickX;
                let annotateY = clickY;
                if (state.rotationAngle !== 0 && state.centerPoint) {
                    const inverted = inverseRotatePoint(clickX, clickY, state.centerPoint.x, state.centerPoint.y, state.rotationAngle);
                    annotateX = inverted.x;
                    annotateY = inverted.y;
                }
                
                const { lon, lat } = canvasToLatLonState(annotateX, annotateY, state.bounds, state);
                
                textArea.value = '';
                textArea.dataset.annotationLon = lon;
                textArea.dataset.annotationLat = lat;
                textArea.dataset.activeGeoId = state.id;
                modalTitle.textContent = 'Add Annotation';
                textArea.style.display = 'block';
                termiteTypeSelect.style.display = 'none';
                modal.classList.add('show');
            }
        }
        
        // Close modal
        function closeModal() {
            modal.classList.remove('show');
            Object.values(canvasStates).forEach(state => {
                state.selectedPinIndex = null;
                state.selectedAnnotationIndex = null;
            });
            Object.values(geoStates).forEach(state => {
                state.selectedPointIndex = null;
                state.selectedAnnotationIndex = null;
            });
            delete textArea.dataset.annotationLon;
            delete textArea.dataset.annotationLat;
            delete textArea.dataset.annotationEdit;
            delete textArea.dataset.drawAnnotationX;
            delete textArea.dataset.drawAnnotationY;
            delete textArea.dataset.drawAnnotationEdit;
            delete textArea.dataset.activeCanvasId;
            delete textArea.dataset.activeGeoId;
            
            // Reset modal to default state
            textArea.style.display = 'block';
            termiteTypeSelect.style.display = 'none';
            modalTitle.textContent = 'Add Custom Text';
        }
        
        // Save custom text
        function saveText() {
            const activeCanvasDatasetId = textArea.dataset.activeCanvasId ? parseInt(textArea.dataset.activeCanvasId, 10) : null;
            const activeGeoDatasetId = textArea.dataset.activeGeoId ? parseInt(textArea.dataset.activeGeoId, 10) : null;
            const targetCanvasState = activeCanvasDatasetId ? canvasStates[activeCanvasDatasetId] : null;
            const targetGeoState = activeGeoDatasetId ? geoStates[activeGeoDatasetId] : null;
            
            if (textArea.dataset.drawAnnotationX && textArea.dataset.drawAnnotationY && targetCanvasState) {
                // Saving new drawing annotation
                const text = textArea.value.trim();
                
                if (text) {
                    targetCanvasState.annotations.push({
                        id: 'draw-annotation-' + Date.now(),
                        x: parseFloat(textArea.dataset.drawAnnotationX),
                        y: parseFloat(textArea.dataset.drawAnnotationY),
                        text: text
                    });
                    renderDrawingAnnotations(targetCanvasState);
                }
                
                delete textArea.dataset.drawAnnotationX;
                delete textArea.dataset.drawAnnotationY;
                delete textArea.dataset.activeCanvasId;
                closeModal();
            } else if (textArea.dataset.drawAnnotationEdit && targetCanvasState && targetCanvasState.selectedAnnotationIndex !== null) {
                // Editing existing drawing annotation
                const text = textArea.value.trim();
                
                if (text) {
                    targetCanvasState.annotations[targetCanvasState.selectedAnnotationIndex].text = text;
                    renderDrawingAnnotations(targetCanvasState);
                }
                
                delete textArea.dataset.drawAnnotationEdit;
                targetCanvasState.selectedAnnotationIndex = null;
                delete textArea.dataset.activeCanvasId;
                closeModal();
            } else if (targetCanvasState && targetCanvasState.selectedPinIndex !== null) {
                // Saving drawing pin text - use dropdown
                const termiteType = termiteTypeSelect.value;
                if (termiteType) {
                    const code = generateRandomCode();
                    const displayText = code + ' ' + termiteType;
                    targetCanvasState.customPins[targetCanvasState.selectedPinIndex].text = displayText;
                    renderDrawingLabels(targetCanvasState);
                }
                targetCanvasState.selectedPinIndex = null;
                delete textArea.dataset.activeCanvasId;
                closeModal();
            } else if (textArea.dataset.annotationLon && textArea.dataset.annotationLat && targetGeoState) {
                // Saving new GeoJSON annotation
                const text = textArea.value.trim();
                
                if (text) {
                    targetGeoState.annotations.push({
                        id: 'annotation-' + Date.now(),
                        lon: parseFloat(textArea.dataset.annotationLon),
                        lat: parseFloat(textArea.dataset.annotationLat),
                        text: text
                    });
                    renderAnnotations(targetGeoState);
                }
                
                delete textArea.dataset.annotationLon;
                delete textArea.dataset.annotationLat;
                delete textArea.dataset.activeGeoId;
                closeModal();
            } else if (textArea.dataset.annotationEdit && targetGeoState && targetGeoState.selectedAnnotationIndex !== null) {
                // Editing existing GeoJSON annotation
                const text = textArea.value.trim();
                
                if (text) {
                    targetGeoState.annotations[targetGeoState.selectedAnnotationIndex].text = text;
                    renderAnnotations(targetGeoState);
                }
                
                delete textArea.dataset.annotationEdit;
                targetGeoState.selectedAnnotationIndex = null;
                delete textArea.dataset.activeGeoId;
                closeModal();
            } else if (targetGeoState && targetGeoState.selectedPointIndex !== null) {
                // Saving GeoJSON point text - use dropdown
                const termiteType = termiteTypeSelect.value;
                if (termiteType) {
                    const code = generateRandomCode();
                    const displayText = code + ' ' + termiteType;
                    const clickedPoint = targetGeoState.pointsData[targetGeoState.selectedPointIndex];
                    clickedPoint.text = displayText;
                    
                    if (clickedPoint.isCustom) {
                        const pin = targetGeoState.customPins.find(p => p.id === clickedPoint.featureId);
                        if (pin) {
                            pin.text = displayText;
                        }
                    } else {
                        targetGeoState.geojson.features.forEach(feature => {
                            if (feature.geometry.type === 'Point' && feature.id === clickedPoint.featureId) {
                                feature.properties.customText = displayText;
                            }
                        });
                    }
                    
                    renderLabels(targetGeoState);
                }
                targetGeoState.selectedPointIndex = null;
                delete textArea.dataset.activeGeoId;
                closeModal();
            }
        }
        
        // Close modal when clicking outside
        modal.addEventListener('click', (e) => {
            if (e.target === modal) {
                closeModal();
            }
        });
        
        // Mode switching
        selectModeBtn.addEventListener('click', () => {
            mode = 'select';
            selectModeBtn.classList.add('mode-active');
            addModeBtn.classList.remove('mode-active');
            annotateModeBtn.classList.remove('mode-active');
            if (activeGeoState) {
                activeGeoState.canvas.style.cursor = 'pointer';
                drawGeoJSON(activeGeoState);
            }
        });
        
        addModeBtn.addEventListener('click', () => {
            mode = 'add';
            addModeBtn.classList.add('mode-active');
            selectModeBtn.classList.remove('mode-active');
            annotateModeBtn.classList.remove('mode-active');
            if (activeGeoState) {
                activeGeoState.canvas.style.cursor = 'crosshair';
                drawGeoJSON(activeGeoState);
            }
        });
        
        annotateModeBtn.addEventListener('click', () => {
            mode = 'annotate';
            annotateModeBtn.classList.add('mode-active');
            selectModeBtn.classList.remove('mode-active');
            addModeBtn.classList.remove('mode-active');
            if (activeGeoState) {
                activeGeoState.canvas.style.cursor = 'text';
                drawGeoJSON(activeGeoState);
            }
        });
        
        // Clear custom pins
        clearPinsBtn.addEventListener('click', () => {
            if (activeGeoState) {
                activeGeoState.customPins = [];
                drawGeoJSON(activeGeoState);
            }
        });
        
        // Export GeoJSON
        exportBtn.addEventListener('click', () => {
            const exportData = {
                type: "FeatureCollection",
                geoViews: Object.values(geoStates).map(state => {
                    const viewData = {
                        id: `geo-view-${state.id}`,
                        type: "FeatureCollection",
                        features: [],
                        metadata: {
                            rotationAngle: state.rotationAngle
                        }
                    };
                    
                    // Add all original features
                    state.geojson.features.forEach(feature => {
                        const featureCopy = JSON.parse(JSON.stringify(feature));
                        viewData.features.push(featureCopy);
                    });
                    
                    // Add custom pins
                    state.customPins.forEach(pin => {
                        viewData.features.push({
                            id: pin.id,
                            type: "Feature",
                            geometry: {
                                type: "Point",
                                coordinates: [pin.lon, pin.lat]
                            },
                            properties: {
                                mode: "point",
                                customText: pin.text || "",
                                isCustomPin: true
                            }
                        });
                    });
                    
                    // Add annotations
                    state.annotations.forEach(ann => {
                        viewData.features.push({
                            id: ann.id,
                            type: "Feature",
                            geometry: {
                                type: "Point",
                                coordinates: [ann.lon, ann.lat]
                            },
                            properties: {
                                mode: "annotation",
                                annotationText: ann.text,
                                isAnnotation: true
                            }
                        });
                    });
                    
                    return viewData;
                })
            };
            
            const jsonString = JSON.stringify(exportData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'exported-geojson-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('GeoJSON exported successfully with all views and annotations!');
        });
        
        // Capture GeoJSON canvas-wrapper as image
        const captureGeoImageBtn = document.getElementById('captureGeoImage');
        captureGeoImageBtn.addEventListener('click', async () => {
            if (!activeGeoState) return;
            
            // Find the active canvas-wrapper
            const activePanel = geoPanels[activeGeoId];
            const canvasWrapper = activePanel.querySelector('.canvas-wrapper');
            
            if (!canvasWrapper) {
                alert('Canvas wrapper not found!');
                return;
            }
            
            try {
                // Show loading message
                captureGeoImageBtn.disabled = true;
                captureGeoImageBtn.textContent = 'Capturing...';
                
                // Create a temporary container with only the elements we want to capture
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.top = '0';
                tempContainer.style.width = activeGeoState.canvas.width + 'px';
                tempContainer.style.height = activeGeoState.canvas.height + 'px';
                tempContainer.style.backgroundColor = '#ffffff';
                tempContainer.style.overflow = 'hidden';
                document.body.appendChild(tempContainer);
                
                // Clone the canvas by creating a new one and copying the image data
                const clonedCanvas = document.createElement('canvas');
                clonedCanvas.width = activeGeoState.canvas.width;
                clonedCanvas.height = activeGeoState.canvas.height;
                const clonedCtx = clonedCanvas.getContext('2d');
                clonedCtx.drawImage(activeGeoState.canvas, 0, 0);
                clonedCanvas.style.position = 'absolute';
                clonedCanvas.style.left = '0';
                clonedCanvas.style.top = '0';
                clonedCanvas.style.display = 'block';
                tempContainer.appendChild(clonedCanvas);
                
                // Clone labels container
                const labelsContainer = activeGeoState.labelsContainer;
                if (labelsContainer && labelsContainer.children.length > 0) {
                    const clonedLabels = labelsContainer.cloneNode(true);
                    clonedLabels.style.position = 'absolute';
                    clonedLabels.style.left = '0';
                    clonedLabels.style.top = '0';
                    clonedLabels.style.width = activeGeoState.canvas.width + 'px';
                    clonedLabels.style.height = activeGeoState.canvas.height + 'px';
                    // Remove borders and shadows from cloned labels
                    Array.from(clonedLabels.querySelectorAll('.point-label')).forEach(label => {
                        label.style.border = 'none';
                        label.style.boxShadow = 'none';
                    });
                    tempContainer.appendChild(clonedLabels);
                }
                
                // Clone annotations container
                const annotationsContainer = activeGeoState.annotationsContainer;
                if (annotationsContainer && annotationsContainer.children.length > 0) {
                    const clonedAnnotations = annotationsContainer.cloneNode(true);
                    clonedAnnotations.style.position = 'absolute';
                    clonedAnnotations.style.left = '0';
                    clonedAnnotations.style.top = '0';
                    clonedAnnotations.style.width = activeGeoState.canvas.width + 'px';
                    clonedAnnotations.style.height = activeGeoState.canvas.height + 'px';
                    // Remove borders and shadows from cloned annotations
                    Array.from(clonedAnnotations.querySelectorAll('.annotation')).forEach(annotation => {
                        annotation.style.border = 'none';
                        annotation.style.boxShadow = 'none';
                    });
                    tempContainer.appendChild(clonedAnnotations);
                }
                
                // Wait a moment for the DOM to update
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Capture the temporary container
                const canvas = await html2canvas(tempContainer, {
                    backgroundColor: '#ffffff',
                    scale: 1,
                    logging: false,
                    useCORS: true,
                    allowTaint: false,
                    width: activeGeoState.canvas.width,
                    height: activeGeoState.canvas.height
                });
                
                // Remove temporary container
                document.body.removeChild(tempContainer);
                
                // Convert to image and download
                const imageData = canvas.toDataURL('image/png');
                const blob = await (await fetch(imageData)).blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `geojson-canvas-${activeGeoId}-${new Date().toISOString().slice(0,10)}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('Image captured successfully!');
            } catch (error) {
                console.error('Error capturing image:', error);
                alert('Error capturing image. Please try again.');
            } finally {
                captureGeoImageBtn.disabled = false;
                captureGeoImageBtn.textContent = 'üì∑ Capture Image';
            }
        });
        
        // GeoJSON tab switching
        function updateGeoPanelVisibility() {
            Object.entries(geoPanels).forEach(([panelId, panelEl]) => {
                const isActive = parseInt(panelId, 10) === activeGeoId;
                panelEl.classList.toggle('active', isActive);
                panelEl.style.display = isActive ? 'block' : 'none';
            });
        }
        
        function setActiveGeo(id) {
            if (activeGeoId === id) {
                updateGeoPanelVisibility();
                return;
            }
            
            activeGeoId = id;
            activeGeoState = geoStates[activeGeoId];
            
            geoTabs.forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.geo-tab[data-geo="${id}"]`).classList.add('active');
            
            updateGeoPanelVisibility();
            
            // Update cursor based on current mode
            if (activeGeoState) {
                if (mode === 'select') {
                    activeGeoState.canvas.style.cursor = 'pointer';
                } else if (mode === 'add') {
                    activeGeoState.canvas.style.cursor = 'crosshair';
                } else if (mode === 'annotate') {
                    activeGeoState.canvas.style.cursor = 'text';
                }
                drawGeoJSON(activeGeoState);
            }
        }
        
        // Initialize GeoJSON states
        geoStates = {
            1: createGeoState(1),
            2: createGeoState(2)
        };
        
        activeGeoId = 1;
        activeGeoState = geoStates[activeGeoId];
        
        // Initialize first view
        drawGeoJSON(activeGeoState);
        updateGeoPanelVisibility();
        
        // Tab switching
        geoTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = parseInt(tab.dataset.geo, 10);
                if (!geoStates[targetId]) return;
                setActiveGeo(targetId);
            });
        });
        
        // View toggle
        geoViewBtn.addEventListener('click', () => {
            mainCanvas.style.display = 'block';
            drawingCanvasContainer.style.display = 'none';
            geoViewBtn.classList.add('mode-active');
            geoViewBtn.classList.remove('btn-secondary');
            geoViewBtn.classList.add('btn-primary');
            drawViewBtn.classList.remove('mode-active');
            drawViewBtn.classList.remove('btn-primary');
            drawViewBtn.classList.add('btn-secondary');
        });
        
        drawViewBtn.addEventListener('click', () => {
            mainCanvas.style.display = 'none';
            drawingCanvasContainer.style.display = 'block';
            drawViewBtn.classList.add('mode-active');
            drawViewBtn.classList.remove('btn-secondary');
            drawViewBtn.classList.add('btn-primary');
            geoViewBtn.classList.remove('mode-active');
            geoViewBtn.classList.remove('btn-primary');
            geoViewBtn.classList.add('btn-secondary');
            initializeDrawingCanvas(activeState);
        });
        
        // Custom Drawing Canvas functionality
        const drawingColorInput = document.getElementById('drawingColor');
        const lineWidthInput = document.getElementById('lineWidth');
        const eraserSizeInput = document.getElementById('eraserSize');
        const eraserSizeContainer = document.getElementById('eraserSizeContainer');
        const eraserTypeContainer = document.getElementById('eraserTypeContainer');
        const eraserTypeSelect = document.getElementById('eraserType');
        const polygonHint = document.getElementById('polygonHint');
        const canvasTabs = document.querySelectorAll('.canvas-tab');
        const canvasPanels = {
            1: document.getElementById('canvasPanel1'),
            2: document.getElementById('canvasPanel2')
        };
        
        // Drawing canvas mode and data
        const drawSelectModeBtn = document.getElementById('drawSelectMode');
        const drawAddPinModeBtn = document.getElementById('drawAddPinMode');
        const drawAnnotateModeBtn = document.getElementById('drawAnnotateMode');
        const drawClearBtn = document.getElementById('drawClear');
        const exportDrawingBtn = document.getElementById('exportDrawing');
        
        let drawMode = 'draw'; // 'draw', 'select', 'addPin', 'annotate'
        let currentTool = 'pencil';
        let drawingColor = '#000000';
        let lineWidth = 2;
        let eraserSize = 20;
        let eraserType = 'circle'; // 'circle' or 'square'
        let lineStyle = 'solid'; // 'solid', 'dashed', 'dotted'
        let rectangleStyle = 'solid'; // 'solid', 'dotted'
        
        function createCanvasState(id) {
            const canvas = document.getElementById(`drawingCanvas${id}`);
            const ctx = canvas.getContext('2d');
            const state = {
                id,
                canvas,
                ctx,
                eraserCursor: document.getElementById(`eraserCursor${id}`),
                textInputBox: document.getElementById(`textInputBox${id}`),
                textInput: document.getElementById(`textInput${id}`),
                labelsContainer: document.getElementById(`drawLabels${id}`),
                annotationsContainer: document.getElementById(`drawAnnotations${id}`),
                previewCanvas: null,
                previewCtx: null,
                customPins: [],
                annotations: [],
                drawingHistory: [],
                polygonPoints: [],
                selectedPinIndex: null,
                selectedAnnotationIndex: null,
                isInitialized: false,
                isDrawing: false,
                startX: 0,
                startY: 0
            };
            
            attachCanvasEvents(state);
            return state;
        }
        
        function attachCanvasEvents(state) {
            state.canvas.addEventListener('mousedown', (e) => handleCanvasMouseDown(e, state));
            state.canvas.addEventListener('mousemove', (e) => handleCanvasMouseMove(e, state));
            state.canvas.addEventListener('mouseup', (e) => handleCanvasMouseUp(e, state));
            state.canvas.addEventListener('mouseleave', () => handleCanvasMouseLeave(state));
            state.canvas.addEventListener('mouseenter', () => handleCanvasMouseEnter(state));
            state.canvas.addEventListener('dblclick', () => handleCanvasDoubleClick(state));
        }
        
        canvasStates = {
            1: createCanvasState(1),
            2: createCanvasState(2)
        };
        
        activeCanvasId = 1;
        activeState = canvasStates[activeCanvasId];
        
        initializeDrawingCanvas(activeState);
        updateCursorForState();
        updateCanvasPanelVisibility();
        
        canvasTabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const targetId = parseInt(tab.dataset.canvas, 10);
                if (!canvasStates[targetId]) return;
                setActiveCanvas(targetId);
            });
        });
        
        drawClearBtn.addEventListener('click', (e) => clearDrawingCanvas(e, activeState));
        
        exportDrawingBtn.addEventListener('click', () => {
            const exportPayload = {
                canvases: Object.values(canvasStates).map(state => ({
                    id: `canvas-${state.id}`,
                    image: state.canvas.toDataURL('image/png'),
                    customPins: state.customPins,
                    annotations: state.annotations
                }))
            };
            
            const jsonString = JSON.stringify(exportPayload, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'custom-drawing-' + new Date().toISOString().slice(0,10) + '.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert('Drawing exported successfully with pins and annotations!');
        });
        
        // Capture Drawing canvas-wrapper as image
        const captureDrawingImageBtn = document.getElementById('captureDrawingImage');
        captureDrawingImageBtn.addEventListener('click', async () => {
            if (!activeState) return;
            
            // Find the active canvas-wrapper
            const activePanel = canvasPanels[activeCanvasId];
            
            if (!activePanel) {
                alert('Canvas wrapper not found!');
                return;
            }
            
            try {
                // Show loading message
                captureDrawingImageBtn.disabled = true;
                captureDrawingImageBtn.textContent = 'Capturing...';
                
                // Hide the drawing tools sidebar and eraser cursor temporarily for cleaner capture
                const drawingTools = document.querySelector('.drawing-tools');
                const originalDisplay = drawingTools ? drawingTools.style.display : '';
                if (drawingTools) {
                    drawingTools.style.display = 'none';
                }
                
                // Hide eraser cursor if visible
                const eraserCursor = activeState.eraserCursor;
                const eraserCursorOriginalDisplay = eraserCursor ? eraserCursor.style.display : '';
                if (eraserCursor) {
                    eraserCursor.style.display = 'none';
                }
                
                // Hide text input box if visible
                const textInputBox = activeState.textInputBox;
                const textInputBoxOriginalDisplay = textInputBox ? textInputBox.style.display : '';
                if (textInputBox) {
                    textInputBox.style.display = 'none';
                }
                
                // Hide preview canvas if it exists
                const previewCanvas = activeState.previewCanvas;
                const previewCanvasOriginalDisplay = previewCanvas ? previewCanvas.style.display : '';
                if (previewCanvas) {
                    previewCanvas.style.display = 'none';
                }
                
                // Wait a moment for the UI to update
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Create a temporary container with only the elements we want to capture
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                tempContainer.style.top = '0';
                tempContainer.style.width = activeState.canvas.width + 'px';
                tempContainer.style.height = activeState.canvas.height + 'px';
                tempContainer.style.backgroundColor = '#ffffff';
                tempContainer.style.overflow = 'hidden';
                document.body.appendChild(tempContainer);
                
                // Clone the canvas by creating a new one and copying the image data
                const clonedCanvas = document.createElement('canvas');
                clonedCanvas.width = activeState.canvas.width;
                clonedCanvas.height = activeState.canvas.height;
                const clonedCtx = clonedCanvas.getContext('2d');
                clonedCtx.drawImage(activeState.canvas, 0, 0);
                clonedCanvas.style.position = 'absolute';
                clonedCanvas.style.left = '0';
                clonedCanvas.style.top = '0';
                clonedCanvas.style.display = 'block';
                tempContainer.appendChild(clonedCanvas);
                
                // Clone labels container
                const labelsContainer = activeState.labelsContainer;
                if (labelsContainer && labelsContainer.children.length > 0) {
                    const clonedLabels = labelsContainer.cloneNode(true);
                    clonedLabels.style.position = 'absolute';
                    clonedLabels.style.left = '0';
                    clonedLabels.style.top = '0';
                    clonedLabels.style.width = activeState.canvas.width + 'px';
                    clonedLabels.style.height = activeState.canvas.height + 'px';
                    // Remove borders and shadows from cloned labels
                    Array.from(clonedLabels.querySelectorAll('.point-label')).forEach(label => {
                        label.style.border = 'none';
                        label.style.boxShadow = 'none';
                    });
                    tempContainer.appendChild(clonedLabels);
                }
                
                // Clone annotations container
                const annotationsContainer = activeState.annotationsContainer;
                if (annotationsContainer && annotationsContainer.children.length > 0) {
                    const clonedAnnotations = annotationsContainer.cloneNode(true);
                    clonedAnnotations.style.position = 'absolute';
                    clonedAnnotations.style.left = '0';
                    clonedAnnotations.style.top = '0';
                    clonedAnnotations.style.width = activeState.canvas.width + 'px';
                    clonedAnnotations.style.height = activeState.canvas.height + 'px';
                    // Remove borders and shadows from cloned annotations
                    Array.from(clonedAnnotations.querySelectorAll('.annotation')).forEach(annotation => {
                        annotation.style.border = 'none';
                        annotation.style.boxShadow = 'none';
                    });
                    tempContainer.appendChild(clonedAnnotations);
                }
                
                // Wait a moment for the DOM to update
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Capture the temporary container
                const canvas = await html2canvas(tempContainer, {
                    backgroundColor: '#ffffff',
                    scale: 1,
                    logging: false,
                    useCORS: true,
                    allowTaint: false,
                    width: activeState.canvas.width,
                    height: activeState.canvas.height
                });
                
                // Remove temporary container
                document.body.removeChild(tempContainer);
                
                // Restore drawing tools, eraser cursor, text input box, and preview canvas
                if (drawingTools) {
                    drawingTools.style.display = originalDisplay;
                }
                if (eraserCursor) {
                    eraserCursor.style.display = eraserCursorOriginalDisplay;
                }
                if (textInputBox) {
                    textInputBox.style.display = textInputBoxOriginalDisplay;
                }
                if (previewCanvas) {
                    previewCanvas.style.display = previewCanvasOriginalDisplay;
                }
                
                // Convert to image and download
                const imageData = canvas.toDataURL('image/png');
                const blob = await (await fetch(imageData)).blob();
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `drawing-canvas-${activeCanvasId}-${new Date().toISOString().slice(0,10)}.png`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                alert('Image captured successfully!');
            } catch (error) {
                console.error('Error capturing image:', error);
                alert('Error capturing image. Please try again.');
            } finally {
                captureDrawingImageBtn.disabled = false;
                captureDrawingImageBtn.textContent = 'üì∑ Capture Image';
            }
        });
        
        function updateCanvasPanelVisibility() {
            Object.entries(canvasPanels).forEach(([panelId, panelEl]) => {
                const isActive = parseInt(panelId, 10) === activeCanvasId;
                panelEl.classList.toggle('active', isActive);
                panelEl.style.display = isActive ? 'block' : 'none';
            });
        }
        
        function setActiveCanvas(id) {
            if (activeCanvasId === id) {
                updateCanvasPanelVisibility();
                return;
            }
            
            // Clear preview and cursors for previous state
            clearPreview(activeState);
            activeState.textInputBox.style.display = 'none';
            activeState.eraserCursor.style.display = 'none';
            activeState.isDrawing = false;
            
            canvasTabs.forEach(tab => tab.classList.remove('active'));
            document.querySelector(`.canvas-tab[data-canvas="${id}"]`).classList.add('active');
            
            Object.entries(canvasPanels).forEach(([panelId, panelEl]) => {
                panelEl.classList.toggle('active', parseInt(panelId, 10) === id);
            });
            
            activeCanvasId = id;
            activeState = canvasStates[activeCanvasId];
            initializeDrawingCanvas(activeState);
            updateCursorForState();
            updateCanvasPanelVisibility();
            renderDrawingLabels(activeState);
            renderDrawingAnnotations(activeState);
        }
        
        function initializeDrawingCanvas(state) {
            if (state.isInitialized) return;
            
            state.ctx.fillStyle = 'white';
            state.ctx.fillRect(0, 0, state.canvas.width, state.canvas.height);
            saveDrawingState(state);
            
            if (!state.previewCanvas) {
                state.previewCanvas = document.createElement('canvas');
                state.previewCanvas.width = state.canvas.width;
                state.previewCanvas.height = state.canvas.height;
                state.previewCanvas.style.position = 'absolute';
                state.previewCanvas.style.left = '0';
                state.previewCanvas.style.top = '0';
                state.previewCanvas.style.pointerEvents = 'none';
                state.previewCanvas.style.border = 'none';
                state.previewCanvas.style.backgroundColor = 'transparent';
                state.previewCanvas.className = 'preview-layer';
                state.canvas.parentElement.appendChild(state.previewCanvas);
                state.previewCtx = state.previewCanvas.getContext('2d');
            }
            
            state.isInitialized = true;
        }
        
        function clearDrawingCanvas(e, state) {
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            state.customPins = [];
            state.annotations = [];
            state.drawingHistory = [];
            state.polygonPoints = [];
            state.ctx.clearRect(0, 0, state.canvas.width, state.canvas.height);
            state.ctx.fillStyle = 'white';
            state.ctx.fillRect(0, 0, state.canvas.width, state.canvas.height);
            
            if (state.previewCtx) {
                state.previewCtx.clearRect(0, 0, state.previewCanvas.width, state.previewCanvas.height);
            }
            
            state.labelsContainer.innerHTML = '';
            state.annotationsContainer.innerHTML = '';
            
            saveDrawingState(state);
        }
        
        function saveDrawingState(state) {
            const imageData = state.ctx.getImageData(0, 0, state.canvas.width, state.canvas.height);
            state.drawingHistory.push(imageData);
            if (state.drawingHistory.length > 50) {
                state.drawingHistory.shift();
            }
        }
        
        function undoDrawing(state = activeState) {
            if (state.drawingHistory.length > 1) {
                state.drawingHistory.pop();
                const previousState = state.drawingHistory[state.drawingHistory.length - 1];
                state.ctx.putImageData(previousState, 0, 0);
                drawPinsOnCanvas(state);
            }
        }
        
        function renderDrawingLabels(state = activeState) {
            state.labelsContainer.innerHTML = '';
            state.customPins.forEach(pin => {
                if (pin.text) {
                    const label = document.createElement('div');
                    label.className = 'point-label';
                    label.textContent = pin.text;
                    label.style.left = (pin.x + 10) + 'px';
                    label.style.top = (pin.y - 10) + 'px';
                    state.labelsContainer.appendChild(label);
                }
            });
        }
        
        function renderDrawingAnnotations(state = activeState) {
            state.annotationsContainer.innerHTML = '';
            
            state.annotations.forEach((annotation, idx) => {
                const label = document.createElement('div');
                label.className = 'annotation';
                label.textContent = annotation.text;
                label.style.left = annotation.x + 'px';
                label.style.top = annotation.y + 'px';
                label.style.transform = 'translate(-50%, -50%)';
                label.style.background = 'rgba(251, 188, 4, 0.95)';
                label.style.cursor = drawMode === 'select' ? 'pointer' : 'default';
                label.style.pointerEvents = drawMode === 'select' ? 'auto' : 'none';
                
                if (drawMode === 'select') {
                    label.addEventListener('click', (e) => {
                        e.stopPropagation();
                        state.selectedAnnotationIndex = idx;
                        textArea.value = annotation.text;
                        textArea.dataset.drawAnnotationEdit = 'true';
                        textArea.dataset.activeCanvasId = state.id;
                        modalTitle.textContent = 'Edit Annotation';
                        textArea.style.display = 'block';
                        termiteTypeSelect.style.display = 'none';
                        modal.classList.add('show');
                    });
                }
                
                state.annotationsContainer.appendChild(label);
            });
        }
        
        function drawPinsOnCanvas(state = activeState) {
            state.customPins.forEach(pin => {
                state.ctx.beginPath();
                state.ctx.arc(pin.x, pin.y, 5, 0, Math.PI * 2);
                state.ctx.fillStyle = '#34a853';
                state.ctx.fill();
                state.ctx.strokeStyle = '#1e8e3e';
                state.ctx.lineWidth = 1;
                state.ctx.stroke();
            });
        }
        
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const tool = btn.dataset.tool;
                
                if (tool === 'undo') {
                    undoDrawing();
                    return;
                }
                
                drawMode = 'draw';
                drawSelectModeBtn.classList.remove('mode-active');
                drawAddPinModeBtn.classList.remove('mode-active');
                drawAnnotateModeBtn.classList.remove('mode-active');
                
                document.querySelectorAll('.tool-btn').forEach(b => {
                    if (b.dataset.tool !== 'undo') {
                        b.classList.remove('active');
                    }
                });
                
                btn.classList.add('active');
                currentTool = tool;
                activeState.polygonPoints = [];
                activeState.textInputBox.style.display = 'none';
                clearPreview(activeState);
                
                if (tool === 'closedPolygon' || tool === 'openPolygon') {
                    polygonHint.classList.add('show');
                } else {
                    polygonHint.classList.remove('show');
                }
                
                if (tool === 'eraser') {
                    eraserSizeContainer.style.display = 'flex';
                    eraserTypeContainer.style.display = 'flex';
                    activeState.canvas.style.cursor = 'none';
                    activeState.eraserCursor.style.display = 'block';
                    activeState.eraserCursor.className = 'eraser-cursor ' + eraserType;
                } else {
                    eraserSizeContainer.style.display = 'none';
                    eraserTypeContainer.style.display = 'none';
                    activeState.eraserCursor.style.display = 'none';
                    activeState.canvas.style.cursor = tool === 'text' ? 'text' : 'crosshair';
                }
            });
        });
        
        drawSelectModeBtn.addEventListener('click', () => {
            drawMode = 'select';
            drawSelectModeBtn.classList.add('mode-active');
            drawAddPinModeBtn.classList.remove('mode-active');
            drawAnnotateModeBtn.classList.remove('mode-active');
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            polygonHint.classList.remove('show');
            activeState.canvas.style.cursor = 'pointer';
            activeState.eraserCursor.style.display = 'none';
            clearPreview(activeState);
            renderDrawingAnnotations(activeState);
        });
        
        drawAddPinModeBtn.addEventListener('click', () => {
            drawMode = 'addPin';
            drawAddPinModeBtn.classList.add('mode-active');
            drawSelectModeBtn.classList.remove('mode-active');
            drawAnnotateModeBtn.classList.remove('mode-active');
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            polygonHint.classList.remove('show');
            activeState.canvas.style.cursor = 'crosshair';
            activeState.eraserCursor.style.display = 'none';
            clearPreview(activeState);
        });
        
        drawAnnotateModeBtn.addEventListener('click', () => {
            drawMode = 'annotate';
            drawAnnotateModeBtn.classList.add('mode-active');
            drawSelectModeBtn.classList.remove('mode-active');
            drawAddPinModeBtn.classList.remove('mode-active');
            document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
            polygonHint.classList.remove('show');
            activeState.canvas.style.cursor = 'text';
            activeState.eraserCursor.style.display = 'none';
            clearPreview(activeState);
        });
        
        drawingColorInput.addEventListener('change', (e) => {
            drawingColor = e.target.value;
        });
        
        lineWidthInput.addEventListener('input', (e) => {
            lineWidth = parseInt(e.target.value, 10);
        });
        
        eraserSizeInput.addEventListener('input', (e) => {
            eraserSize = parseInt(e.target.value, 10);
            Object.values(canvasStates).forEach(state => {
                state.eraserCursor.style.width = eraserSize + 'px';
                state.eraserCursor.style.height = eraserSize + 'px';
            });
        });
        
        eraserTypeSelect.addEventListener('change', (e) => {
            eraserType = e.target.value;
            Object.values(canvasStates).forEach(state => {
                state.eraserCursor.className = 'eraser-cursor ' + eraserType;
            });
        });
        
        // Style selector functionality
        const styleSelectorBtn = document.getElementById('styleSelectorBtn');
        const styleSelectorDropdown = document.getElementById('styleSelectorDropdown');
        
        // Toggle dropdown
        styleSelectorBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            styleSelectorDropdown.classList.toggle('show');
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            if (!styleSelectorBtn.contains(e.target) && !styleSelectorDropdown.contains(e.target)) {
                styleSelectorDropdown.classList.remove('show');
            }
        });
        
        // Handle style option selection
        document.querySelectorAll('.style-option').forEach(option => {
            option.addEventListener('click', (e) => {
                const type = option.dataset.type;
                const style = option.dataset.style;
                
                // Update active state
                document.querySelectorAll(`.style-option[data-type="${type}"]`).forEach(opt => {
                    opt.classList.remove('active');
                });
                option.classList.add('active');
                
                // Update style variables
                if (type === 'line') {
                    lineStyle = style;
                } else if (type === 'rectangle') {
                    rectangleStyle = style;
                }
                
                // Update button text to show current styles
                updateStyleButtonText();
            });
        });
        
        function updateStyleButtonText() {
            const lineStyleText = lineStyle.charAt(0).toUpperCase() + lineStyle.slice(1);
            const rectStyleText = rectangleStyle.charAt(0).toUpperCase() + rectangleStyle.slice(1);
            styleSelectorBtn.textContent = `‚öôÔ∏è Line: ${lineStyleText} | Rect: ${rectStyleText}`;
        }
        
        // Initialize button text
        updateStyleButtonText();
        
        // Helper function to get line dash pattern based on style
        function getLineDashPattern(style) {
            switch(style) {
                case 'dashed':
                    return [10, 5];
                case 'dotted':
                    return [2, 5];
                case 'solid':
                default:
                    return [];
            }
        }
        
        function handleCanvasMouseDown(e, state) {
            if (state.id !== activeCanvasId) return;
            const { x, y } = getCanvasCoordinates(e, state);
            state.startX = x;
            state.startY = y;
            
            if (drawMode === 'select') {
                state.customPins.forEach((pin, idx) => {
                    const distance = Math.hypot(x - pin.x, y - pin.y);
                    if (distance <= 8) {
                        state.selectedPinIndex = idx;
                        textArea.dataset.activeCanvasId = state.id;
                        termiteTypeSelect.value = pin.text || '';
                        modalTitle.textContent = 'Select Termite Type';
                        textArea.style.display = 'none';
                        termiteTypeSelect.style.display = 'block';
                        modal.classList.add('show');
                    }
                });
                return;
            }
            
            if (drawMode === 'addPin') {
                const newPin = {
                    id: 'draw-pin-' + Date.now(),
                    x,
                    y,
                    text: ''
                };
                state.customPins.push(newPin);
                drawPinsOnCanvas(state);
                renderDrawingLabels(state);
                saveDrawingState(state);
                return;
            }
            
            if (drawMode === 'annotate') {
                textArea.value = '';
                textArea.dataset.drawAnnotationX = x;
                textArea.dataset.drawAnnotationY = y;
                textArea.dataset.activeCanvasId = state.id;
                textArea.style.display = 'block';
                termiteTypeSelect.style.display = 'none';
                modalTitle.textContent = 'Add Annotation';
                modal.classList.add('show');
                return;
            }
            
            if (currentTool === 'text') {
                state.textInputBox.style.display = 'block';
                state.textInputBox.style.left = x + 'px';
                state.textInputBox.style.top = y + 'px';
                state.textInput.value = '';
                state.textInput.focus();
                
                const submitText = () => {
                    const value = state.textInput.value.trim();
                    if (value) {
                        state.ctx.fillStyle = drawingColor;
                        state.ctx.font = `${lineWidth * 8}px Arial`;
                        state.ctx.fillText(value, x, y + lineWidth * 8);
                        saveDrawingState(state);
                    }
                    state.textInputBox.style.display = 'none';
                    state.textInput.removeEventListener('blur', submitText);
                    state.textInput.removeEventListener('keypress', handleEnter);
                };
                
                const handleEnter = (event) => {
                    if (event.key === 'Enter') {
                        submitText();
                    }
                };
                
                state.textInput.addEventListener('blur', submitText, { once: true });
                state.textInput.addEventListener('keypress', handleEnter);
                return;
            }
            
            if (currentTool === 'closedPolygon' || currentTool === 'openPolygon') {
                state.polygonPoints.push({ x, y });
                state.ctx.fillStyle = drawingColor;
                state.ctx.beginPath();
                state.ctx.arc(x, y, 3, 0, Math.PI * 2);
                state.ctx.fill();
                
                if (state.polygonPoints.length > 1) {
                    const prev = state.polygonPoints[state.polygonPoints.length - 2];
                    state.ctx.strokeStyle = drawingColor;
                    state.ctx.lineWidth = lineWidth;
                    state.ctx.beginPath();
                    state.ctx.moveTo(prev.x, prev.y);
                    state.ctx.lineTo(x, y);
                    state.ctx.stroke();
                }
                return;
            }
            
            state.isDrawing = true;
        }
        
        function handleCanvasMouseMove(e, state) {
            if (state.id !== activeCanvasId) return;
            const { x, y } = getCanvasCoordinates(e, state);
            
            if (currentTool === 'eraser' && drawMode === 'draw') {
                state.eraserCursor.style.display = 'block';
                state.eraserCursor.style.left = (x - eraserSize / 2) + 'px';
                state.eraserCursor.style.top = (y - eraserSize / 2) + 'px';
                state.eraserCursor.style.width = eraserSize + 'px';
                state.eraserCursor.style.height = eraserSize + 'px';
            }
            
            if (!state.isDrawing) {
                if ((currentTool === 'closedPolygon' || currentTool === 'openPolygon') && state.polygonPoints.length > 0 && state.previewCtx) {
                    state.previewCtx.clearRect(0, 0, state.previewCanvas.width, state.previewCanvas.height);
                    const lastPoint = state.polygonPoints[state.polygonPoints.length - 1];
                    state.previewCtx.strokeStyle = drawingColor;
                    state.previewCtx.lineWidth = lineWidth;
                    state.previewCtx.setLineDash([5, 5]);
                    state.previewCtx.beginPath();
                    state.previewCtx.moveTo(lastPoint.x, lastPoint.y);
                    state.previewCtx.lineTo(x, y);
                    state.previewCtx.stroke();
                    
                    if (currentTool === 'closedPolygon' && state.polygonPoints.length > 2) {
                        const firstPoint = state.polygonPoints[0];
                        state.previewCtx.beginPath();
                        state.previewCtx.moveTo(x, y);
                        state.previewCtx.lineTo(firstPoint.x, firstPoint.y);
                        state.previewCtx.stroke();
                    }
                    
                    state.previewCtx.setLineDash([]);
                }
                return;
            }
            
            if (drawMode !== 'draw') return;
            
            if (state.previewCtx) {
                state.previewCtx.clearRect(0, 0, state.previewCanvas.width, state.previewCanvas.height);
            }
            
            if (currentTool === 'pencil') {
                state.ctx.strokeStyle = drawingColor;
                state.ctx.lineWidth = lineWidth;
                state.ctx.lineCap = 'round';
                state.ctx.beginPath();
                state.ctx.moveTo(state.startX, state.startY);
                state.ctx.lineTo(x, y);
                state.ctx.stroke();
                state.startX = x;
                state.startY = y;
            } else if (currentTool === 'eraser') {
                if (eraserType === 'circle') {
                    state.ctx.save();
                    state.ctx.globalCompositeOperation = 'destination-out';
                    state.ctx.beginPath();
                    state.ctx.arc(x, y, eraserSize / 2, 0, Math.PI * 2);
                    state.ctx.fill();
                    state.ctx.restore();
                } else {
                    state.ctx.clearRect(x - eraserSize / 2, y - eraserSize / 2, eraserSize, eraserSize);
                }
            } else if (state.previewCtx) {
                state.previewCtx.strokeStyle = drawingColor;
                state.previewCtx.lineWidth = lineWidth;
                if (currentTool === 'line') {
                    const dashPattern = getLineDashPattern(lineStyle);
                    state.previewCtx.setLineDash(dashPattern.length > 0 ? [5, 5] : []); // Preview with dashed pattern
                    state.previewCtx.beginPath();
                    state.previewCtx.moveTo(state.startX, state.startY);
                    state.previewCtx.lineTo(x, y);
                    state.previewCtx.stroke();
                } else if (currentTool === 'rectangle') {
                    const dashPattern = getLineDashPattern(rectangleStyle);
                    state.previewCtx.setLineDash(dashPattern.length > 0 ? [5, 5] : []); // Preview with dashed pattern
                    state.previewCtx.strokeRect(state.startX, state.startY, x - state.startX, y - state.startY);
                } else if (currentTool === 'circle') {
                    const radius = Math.hypot(x - state.startX, y - state.startY);
                    state.previewCtx.beginPath();
                    state.previewCtx.arc(state.startX, state.startY, radius, 0, Math.PI * 2);
                    state.previewCtx.stroke();
                }
                state.previewCtx.setLineDash([]);
            }
        }
        
        function handleCanvasMouseUp(e, state) {
            if (state.id !== activeCanvasId || !state.isDrawing || drawMode !== 'draw') return;
            const { x, y } = getCanvasCoordinates(e, state);
            
            const finalColor = (drawingColor === '#ffffff' || drawingColor === '#FFFFFF') ? '#000000' : drawingColor;
            state.ctx.strokeStyle = finalColor;
            state.ctx.fillStyle = finalColor;
            state.ctx.lineWidth = lineWidth;
            state.ctx.lineCap = 'round';
            state.ctx.lineJoin = 'round';
            
            if (currentTool === 'line') {
                const dashPattern = getLineDashPattern(lineStyle);
                state.ctx.setLineDash(dashPattern);
                state.ctx.beginPath();
                state.ctx.moveTo(state.startX, state.startY);
                state.ctx.lineTo(x, y);
                state.ctx.stroke();
                state.ctx.setLineDash([]);
            } else if (currentTool === 'rectangle') {
                const dashPattern = getLineDashPattern(rectangleStyle);
                state.ctx.setLineDash(dashPattern);
                state.ctx.beginPath();
                state.ctx.rect(state.startX, state.startY, x - state.startX, y - state.startY);
                state.ctx.stroke();
                state.ctx.setLineDash([]);
            } else if (currentTool === 'circle') {
                const radius = Math.hypot(x - state.startX, y - state.startY);
                state.ctx.beginPath();
                state.ctx.arc(state.startX, state.startY, radius, 0, Math.PI * 2);
                state.ctx.stroke();
            }
            
            state.isDrawing = false;
            clearPreview(state);
            drawPinsOnCanvas(state);
            saveDrawingState(state);
        }
        
        function handleCanvasMouseLeave(state) {
            if (state.previewCtx) {
                state.previewCtx.clearRect(0, 0, state.previewCanvas.width, state.previewCanvas.height);
            }
            state.eraserCursor.style.display = 'none';
            state.isDrawing = false;
        }
        
        function handleCanvasMouseEnter(state) {
            if (state.id !== activeCanvasId) return;
            if (currentTool === 'eraser' && drawMode === 'draw') {
                state.eraserCursor.style.display = 'block';
            }
        }
        
        function handleCanvasDoubleClick(state) {
            if (state.id !== activeCanvasId) return;
            if ((currentTool === 'closedPolygon' || currentTool === 'openPolygon') && state.polygonPoints.length > 2 && drawMode === 'draw') {
                completePolygon(state);
            }
        }
        
        function updateCursorForState() {
            if (drawMode === 'select') {
                activeState.canvas.style.cursor = 'pointer';
            } else if (drawMode === 'annotate') {
                activeState.canvas.style.cursor = 'text';
            } else if (drawMode === 'addPin') {
                activeState.canvas.style.cursor = 'crosshair';
            } else {
                activeState.canvas.style.cursor = currentTool === 'text' ? 'text' : (currentTool === 'eraser' ? 'none' : 'crosshair');
            }
            
            if (currentTool === 'eraser' && drawMode === 'draw') {
                activeState.eraserCursor.style.display = 'block';
            } else {
                activeState.eraserCursor.style.display = 'none';
            }
        }
        
        function completePolygon(state) {
            if (state.polygonPoints.length < 2) return;
            
            state.ctx.strokeStyle = drawingColor;
            state.ctx.lineWidth = lineWidth;
            
            if (currentTool === 'closedPolygon') {
                const first = state.polygonPoints[0];
                const last = state.polygonPoints[state.polygonPoints.length - 1];
                state.ctx.beginPath();
                state.ctx.moveTo(last.x, last.y);
                state.ctx.lineTo(first.x, first.y);
                state.ctx.stroke();
            }
            
            state.polygonPoints = [];
            clearPreview(state);
            drawPinsOnCanvas(state);
            saveDrawingState(state);
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && (currentTool === 'closedPolygon' || currentTool === 'openPolygon') && activeState.polygonPoints.length > 1 && drawMode === 'draw') {
                completePolygon(activeState);
            }
        });
        
        function clearPreview(state) {
            if (state.previewCtx) {
                state.previewCtx.clearRect(0, 0, state.previewCanvas.width, state.previewCanvas.height);
            }
        }
        
        function getCanvasCoordinates(event, state) {
            const rect = state.canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }
        
        // Generate random 2-character code (A-Z)(0-9)
        function generateRandomCode() {
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            const letter = letters[Math.floor(Math.random() * letters.length)];
            const digit = Math.floor(Math.random() * 10);
            return letter + digit;
        }
    </script>
</body>
</html>